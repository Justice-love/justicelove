<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title>记一次java native memory增长问题的排查 &#8211; 轶 & 霄</title> <meta name="description" content="我们的小窝"> <meta name="keywords" content="java, heap, memory"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="//justice-love.com/assets/img/logo.png"> <meta name="twitter:title" content="记一次java native memory增长问题的排查"> <meta name="twitter:description" content="转载自 @蛋疼的axb"> <!-- Open Graph --> <meta property="og:locale" content="zh_CN"> <meta property="og:type" content="article"> <meta property="og:title" content="记一次java native memory增长问题的排查"> <meta property="og:description" content="转载自 @蛋疼的axb"> <meta property="og:url" content="//justice-love.com/java-memory/"> <meta property="og:site_name" content="轶 & 霄"> <meta property="og:image" content="//justice-love.com/assets/img/logo.png"> <link rel="canonical" href="//justice-love.com/java-memory/"> <link href="//justice-love.com/feed.xml" type="application/atom+xml" rel="alternate" title="轶 & 霄 Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="//justice-love.com/assets/css/main.css"> <link rel="stylesheet" href="//justice-love.com/assets/css/share.min.css"> <!-- JS --> <script src="//justice-love.com/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="//justice-love.com/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="//justice-love.com/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="//justice-love.com/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="//justice-love.com/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="//justice-love.com/favicon.png" /> <link rel="shortcut icon" href="//justice-love.com/favicon.ico" /> <!-- video --> <!-- Background Image --> <style type="text/css">body {background-image:url(https://cdn.justice-love.com/image/jpg/bjtp1.jpg); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> <script> var _hmt = _hmt || []; (function() { var hm = document.createElement("script"); hm.src = "https://hm.baidu.com/hm.js?b8fa0aab7976f4bd13b1648e04c7243f"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s); })(); </script> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="//justice-love.com/">Home</a></li> <li> <a href="#">Articles</a> <ul class="dl-submenu"> <li><a href="//justice-love.com/posts/">日志</a></li> <li><a href="//justice-love.com/yan/">妍小言</a></li> <li><a href="//justice-love.com/shu/">舒小书</a></li> <li><a href="//justice-love.com/haoran/">浩然说</a></li> <li><a href="//justice-love.com/life/">生活日记</a></li> </ul> </li> <li><a href="//justice-love.com/tags/" >All Tags</a></li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper-page animated fadeIn"> <div class="content"> <div class="post-title "> <h1>记一次java native memory增长问题的排查</h1> <h4>29 Nov 2016</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~2 minutes </p><!-- /.entry-reading-time --> <a class="btn zoombtn" href="//justice-love.com/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <div style="font-size: 15px"> <h1 id="1摘要">1.摘要</h1> <p>最近排查了一个比较灵异的线上jvm内存持续增长的问题，排查过程异常艰辛，但是最后竟然是用最简单的办法搞定了……</p> <h1 id="2现象">2.现象</h1> <p>线上机器部署了两个java实例，在运行几天后java开始吃swap空间，java实例的内存占用接近7G，程序响应很慢，重启后又恢复正常。线上配置的堆内存为3600M，栈大小为512k。</p> <h1 id="3排查">3.排查</h1> <p>首先怀疑是java heap的问题，查看heap占用内存，没有什么特殊。</p> <p><code class="language-plaintext highlighter-rouge">$ jmap -heap pid</code></p> <p>然后又怀疑是directbuffer的问题，jdk1.7之后对directbuffer监控的支持变得简单了一些，使用如下脚本：</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.io.File;
import java.util.*;
import java.lang.management.BufferPoolMXBean;
import java.lang.management.ManagementFactory;
import javax.management.MBeanServerConnection;
import javax.management.ObjectName;
import javax.management.remote.*;

import com.sun.tools.attach.VirtualMachine; // Attach API

/**
 * Simple tool to attach to running VM to report buffer pool usage.
 */

public class MonBuffers {
    static final String CONNECTOR_ADDRESS =
          "com.sun.management.jmxremote.localConnectorAddress";

    public static void main(String args[]) throws Exception {
        // attach to target VM to get connector address
        VirtualMachine vm = VirtualMachine.attach(args[0]);
        String connectorAddress = vm.getAgentProperties().getProperty(CONNECTOR_ADDRESS);
        if (connectorAddress == null) {
            // start management agent
            String agent = vm.getSystemProperties().getProperty("java.home") +
                    File.separator + "lib" + File.separator + "management-agent.jar";
            vm.loadAgent(agent);
            connectorAddress = vm.getAgentProperties().getProperty(CONNECTOR_ADDRESS);
            assert connectorAddress != null;
        }

        // connect to agent
        JMXServiceURL url = new JMXServiceURL(connectorAddress);
        JMXConnector c = JMXConnectorFactory.connect(url);
        MBeanServerConnection server = c.getMBeanServerConnection();

        // get the list of pools
        Set&lt;ObjectName&gt; mbeans = server.queryNames(
            new ObjectName("java.nio:type=BufferPool,*"), null);
        List&lt;BufferPoolMXBean&gt; pools = new ArrayList&lt;BufferPoolMXBean&gt;();
        for (ObjectName name: mbeans) {
            BufferPoolMXBean pool = ManagementFactory
                .newPlatformMXBeanProxy(server, name.toString(), BufferPoolMXBean.class);
            pools.add(pool);
        }

        // print headers
        for (BufferPoolMXBean pool: pools)
            System.out.format("         %8s             ", pool.getName());
        System.out.println();
        for (int i=0; i&lt;pools.size(); i++)
            System.out.format("%6s %10s %10s  ",  "Count", "Capacity", "Memory");
        System.out.println();

        // poll and print usage
        for (;;) {
            for (BufferPoolMXBean pool: pools) {
                System.out.format("%6d %10d %10d  ",
                    pool.getCount(), pool.getTotalCapacity(), pool.getMemoryUsed());
            }
            System.out.println();
            Thread.sleep(2000);
        }
    }
}

</code></pre></div></div> <p>发现directbuffer虽然在增长，但是也只有百兆左右。full gc之后缩小到十几兆，可以忽略。</p> <p>查看java线程的情况，虽然线程数很多，但是内存增长时线程数基本没有什么变化。</p> <p><code class="language-plaintext highlighter-rouge">$ jstack pid |grep 'java.lang.Thread.State' |wc -l</code></p> <p>或者</p> <p><code class="language-plaintext highlighter-rouge">$ cat /proc/pid/status |grep Thread</code></p> <p>对java做了一次heap dump，使用eclipse的MAT查看堆内使用情况，没有发现明显有哪个对象数量有明显异常，heap的大小也只有几百兆。</p> <p><code class="language-plaintext highlighter-rouge">$ jmap -dump:file=/tmp/heap.bin</code></p> <p>发现stack dump里的global jni reference一直在增长，怀疑是jni调用存在内存溢出。</p> <p><code class="language-plaintext highlighter-rouge">$ jstack pid |grep JNI</code></p> <p>查找了jar包里的.so/.h等c文件，发现jruby、jthon等jar包里有jni相关的文件。</p> <p><code class="language-plaintext highlighter-rouge">$ wtool jarfind *.so .</code></p> <p>上网发现确实有不少<a href="https://github.com/jruby/jruby/issues/1888">jruby内存溢出的issue</a>。把这些jar包直接删掉之后观察global jni reference数量还是在涨，内存增长情况也没有改善。</p> <p>之后突然想到full gc的问题，对增长中的java进程做了一次full gc，global jni reference数量由几千个下降到几十个，但是占用内存还是没有变化，排除掉global reference的可能性。</p> <p>用pmap查看进程内的内存情况，发现java的heap和stack大小都没啥变化，但是定期会多出来一个64M左右的内存块。</p> <p><code class="language-plaintext highlighter-rouge">$ pmap -x pid |less</code></p> <p><img src="http://blog.2baxb.me/wp-content/uploads/2014/11/64m.jpg" alt="pmap截图" /></p> <p>使用gdb观察内存块里的内容，发现里面有一些接口的返回值、mc的返回值、还有一些类名等等</p> <p><code class="language-plaintext highlighter-rouge">gdb: dump memory /tmp/memory.bin 0x7f6b38000000 0x7f6b38000000+65535000</code></p> <p><code class="language-plaintext highlighter-rouge">$ hexdump -C /tmp/memory.bin</code>或<code class="language-plaintext highlighter-rouge">$ strings /tmp/memory.bin |less</code></p> <p><img src="http://blog.2baxb.me/wp-content/uploads/2014/11/hexdump.jpg" alt="hexdump截图" /></p> <p>上网搜索后发现有人遇到过这个问题，在<a href="https://www.ibm.com/developerworks/community/blogs/kevgrig/entry/linux_glibc_2_10_rhel_6_malloc_may_show_excessive_virtual_memory_usage?lang=en">这个网页里</a>有ibm对64M问题的研究。依照网站上说的办法，把MALLOC_ARENA_MAX参数调成1，发现virtual memory正常了，res也小了1G左右。同时<a href="https://issues.apache.org/jira/browse/HADOOP-7154">hadoop的issue里</a>也有一些性能方面的测试，发现MALLOC_ARENA_MAX=4的时候性能会提升，但是他们也说不清楚为什么。</p> <p>修改之后程序启动时的virtual memory明显降低，res也降低到了3.2g： <img src="http://blog.2baxb.me/wp-content/uploads/2014/11/max.jpg" alt="memory" /></p> <p>本来以为到这里应该算是解决了，但是这个程序跑了几天之后内存依然在上涨,只是内存块由很多64M变成了一个2g+的普通native heap。</p> <p>继续寻找线索，在一些关于MALLOC_ARENA_MAX这个参数的讨论里也发现一些关于glibc的其它参数。比如<a href="http://mqzhuang.iteye.com/blog/1014287">M_TRIM_THRESHOLD和M_MMAP_THRESHOLD</a>或者<a href="https://www.ibm.com/developerworks/community/blogs/kevgrig/entry/linux_native_memory_fragmentation_and_process_size_growth?lang=en">MALLOC_MMAP_MAX_</a>，试用之后发现依然没有效果。</p> <p>试着从glibc的malloc实现上找问题，比如<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=14581">这里</a>和<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=11261">这里</a>，同样没有什么进展。</p> <p>尝试用strace和ltrace查找malloc调用，发现定期有32k的内存申请，但是无法确定是从哪调用的。</p> <p>尝试用valgrind查找内存泄露，但是jvm跑在valgrind上几分钟就crash了。</p> <p>在网上查到了一个关于thread pool用法错误有可能导致内存溢出的问题，可以写一个小程序重现：</p> <p>但是用btrace挂了一天也没有发现有错误的调用，源代码里也没找到类似的用法。</p> <p>重新用MAT在heap dump里查找是否有native reference，发现finalizer队列里有很多java.util.zip.Deflater的实例，上网搜索发现这个类有可能导致native内存溢出，使用的jesery框架里有<a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCAQFjAA&amp;url=https://java.net/jira/browse/JERSEY-1647&amp;ei=ikNYVNinJo72igKBvIGQAQ&amp;usg=AFQjCNF5iKZPZZgVhs4pMAYJjvkZrogfKg&amp;sig2=lFm6sK_rGlTsggZzz0B-gA">这个问题导致gzip异常的issue</a>；用btrace监视发现有大量这个类的构造函数被调用，但是经过几次full gc的观察，每次full gc后finalizer队列里的Deflater数量都会减少到个位数，但是内存依然在上涨；同时排查了线上配置，发现没有开启gzip。</p> <p>也发现了有人说<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1028966">SunPKCS11</a>有可能导致内存泄露，但是也没发现有相关java对象。</p> <p>尝试把Xss参数调到256k，运行几天后发现内存维持在5.7g左右，比较稳定，但是从各种角度都无法解释为什么xss调小会影响native heap的大小。</p> <p>怀疑是JIT的问题，用-Xint或者-XX:-Inline方式启动之后发现内存依然增长。</p> <p>本来排查到这里已经绝望了，但是最后想到是不是JDK本身有什么bug？</p> <p>查看jdk的changelog，发现线上使用的1.7-b15的版本比较老，之后有一些对native memory leak的修复。尝试用新的jdk1.7-u71启动应用，内存竟然稳定下来了！</p> <p>在升级jdk、限制directbuffer大小为256M、调整MALLOC_ARENA_MAX=1后，4倍流量的tcpcopy运行几天后内存占用稳定在5G；只升级了jdk，其它参数不变，运行一天后内存为5.4G，是否上涨还有待观察。对比之前占用6.8G左右，效果还是比较明显的。</p> <h1 id="4其它参考资料">4.其它参考资料</h1> <ol> <li>java 的堆外内存溢出最近也碰到过几次，有一次是jdk6的一个directbuffer不释放，有jdk6的String.intern 非fullgc不释放。还有就是gzip流不显式关闭也会导致Deflater内存溢出。 找起来 都真是难啊</li> <li>directbuffer在jdk7之后监控变得简单一些了，native的内存确实比较难查。</li> </ol> <h3 id="原文作者蛋疼的axb-文章源链接"><a href="http://blog.2baxb.me/archives/918">原文作者@蛋疼的axb, 文章源链接</a></h3> </div> <div class="entry-meta"> <br> <hr> <script src="https://apps.bdimg.com/libs/jquery/1.8.2/jquery.js"></script> <script src="//justice-love.com/assets/js/jquery.share.min.js"></script> <span class="entry-tags"><a href="//justice-love.com/tags/#java" title="Pages tagged java" class="tag"><span class="term">java</span></a><a href="//justice-love.com/tags/#heap" title="Pages tagged heap" class="tag"><span class="term">heap</span></a><a href="//justice-love.com/tags/#memory" title="Pages tagged memory" class="tag"><span class="term">memory</span></a></span> <div id="share-china"></div> <div style="clear:both"></div> <script> $('#share-china').share({sites: ['qzone', 'weibo','wechat', 'facebook', 'twitter']}); </script> </div> </div> </div> <section id="disqus_thread" class="animated fadeInUp"> <div id="gitalk-container"></div> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script type="text/javascript"> var id = document.URL; if (id.indexOf('?') > 0) { id = id.substr(0, id.indexOf('?')); } const gitalk = new Gitalk({ clientID: '94ea015a2463191dc163', clientSecret: '5fba2b9dc7bf84584dd7a7d8d070e3c0e9d260bf', accessToken: '5facc6f1b9b0e6f0e66e986ba01423102f89d5c7', repo: 'blog-comments', owner: 'Justice-love', admin: ['Justice-love'], distractionFreeMode: false, labels: ['comments'], title: '记一次java native memory增长问题的排查', id: id }); gitalk.render('gitalk-container'); </script> </section> </header> <!-- JS --> <script src="//justice-love.com/assets/js/jquery-3.6.0.min.js"></script> <script src="//justice-love.com/assets/js/jquery.dlmenu.min.js"></script> <script src="//justice-love.com/assets/js/jquery.goup.min.js"></script> <script src="//justice-love.com/assets/js/jquery.magnific-popup.min.js"></script> <script src="//justice-love.com/assets/js/jquery.fitvid.min.js"></script> <script src="//justice-love.com/assets/js/scripts.js"></script> <script src="//justice-love.com/assets/js/clipboard.min.js"></script> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
